# -*- coding: utf-8 -*-
"""Covid 19 - Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vXlrXucOvPPvEv_J3wuLVTyO9_h_BYj9

### Importing Libraries
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_curve, auc
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB

"""### Importing Dataset"""

from google.colab import files
uploaded = files.upload()
df = pd.read_csv('Covid Dataset.csv')

"""### Dataset Information"""

print("\nShape of the Dataset (Rows, Columns):")
print(df.shape)

print("\nData Types of Each Column:")
print(df.dtypes)

"""### Distribution of Target Variable"""

print(df['COVID-19'].value_counts())

plt.figure(figsize=(6, 4))
sns.countplot(x='COVID-19', data=df, hue='COVID-19', palette='Set2', legend=False)
plt.title('Distribution of COVID-19 Cases')
plt.xlabel('COVID-19')
plt.ylabel('Count')
plt.show()

print(df.head())

"""### Label Encoder"""

label_encoder = LabelEncoder()

for column in df.select_dtypes(include=['object']).columns:
    df[column] = label_encoder.fit_transform(df[column])

print(df.head())

"""### Undersampling"""

covid_positive = df[df['COVID-19'] == 1]
covid_negative = df[df['COVID-19'] == 0]

num_to_remove = abs(len(covid_positive) - len(covid_negative))

if num_to_remove > 0:
    if len(covid_positive) > len(covid_negative):
        rows_to_remove = covid_positive.sample(n=num_to_remove, random_state=0).index
    else:
        rows_to_remove = covid_negative.sample(n=num_to_remove, random_state=0).index

    df = df.drop(rows_to_remove)

print(df['COVID-19'].value_counts())

"""### Distribution of Target Variable"""

plt.figure(figsize=(6, 4))
sns.countplot(x='COVID-19', data=df, hue='COVID-19', palette='Set2', legend=False)
plt.title('Distribution of COVID-19 Cases')
plt.xlabel('COVID-19')
plt.ylabel('Count')
plt.show()

"""### Checking Missing Values"""

print("\nMissing Values: \n")
print(df.isnull().sum())

"""### Correlation Heatmap"""

correlation_matrix = df.corr()
plt.figure(figsize=(12, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Heatmap')
plt.show()

"""### Dropping Features"""

df = df.drop(columns=['Wearing Masks'])
df = df.drop(columns=['Sanitization from Market'])

"""### Feature-Target Split"""

X = df.iloc[:, :-1]
y = df.iloc[:, -1]

"""### Split data into train and test sets"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)
print ('Train set:', X_train.shape,  y_train.shape)
print ('Test set:', X_test.shape,  y_test.shape)

"""### Train logistic regression model"""

modelLR = LogisticRegression()
modelLR.fit(X_train, y_train)

"""### Prediction for logistic Regression"""

y_predLR = modelLR.predict(X_test)

"""### Model evaluation"""

accuracy = accuracy_score(y_test, y_predLR)
conf_matrix = confusion_matrix(y_test, y_predLR)
class_report = classification_report(y_test, y_predLR)

print(f'Accuracy: {accuracy*100:.2f}')
print('\nConfusion Matrix:\n', conf_matrix)
print('\nClassification Report:\n', class_report)

"""### Train KNN Model"""

classifier = KNeighborsClassifier(n_neighbors = 5, metric = 'minkowski', p = 2)
classifier.fit(X_train, y_train)

"""### Prediction for KNN"""

y_predKNN = classifier.predict(X_test)

"""### KNN Model Evaluation"""

accuracy = accuracy_score(y_test, y_predKNN)
conf_matrix = confusion_matrix(y_test, y_predKNN)
class_report = classification_report(y_test, y_predKNN)

print(f'Accuracy: {accuracy*100:.2f}')
print('\nConfusion Matrix:\n', conf_matrix)
print('\nClassification Report:\n', class_report)

"""### Train Random Forest Classifier"""

modelRF = RandomForestClassifier(n_estimators=100, random_state=0)
modelRF.fit(X_train, y_train)

"""### Prediction for Random Forest Classifier"""

y_predRF = modelRF.predict(X_test)

"""### Random Forest Evaluation"""

accuracy = accuracy_score(y_test, y_predRF)
conf_matrix = confusion_matrix(y_test, y_predRF)
class_report = classification_report(y_test, y_predRF)

print('Random Forest')
print(f'Accuracy: {accuracy*100:.2f}')
print('\nConfusion Matrix:\n', conf_matrix)
print('\nClassification Report:\n', class_report)

"""### Train SVM"""

modelSVM = SVC(kernel='linear', random_state=0)  # You can experiment with different kernels like 'rbf', 'poly'
modelSVM.fit(X_train, y_train)

"""### Prediction for SVM"""

y_predSVM = modelSVM.predict(X_test)

"""### Evaluation for SVM"""

accuracy = accuracy_score(y_test, y_predSVM)
conf_matrix = confusion_matrix(y_test, y_predSVM)
class_report = classification_report(y_test, y_predSVM)

print(f'Accuracy: {accuracy*100:.2f}')
print('\nConfusion Matrix:\n', conf_matrix)
print('\nClassification Report:\n', class_report)

"""### Train Naive Bayes"""

modelNB = GaussianNB()
modelNB.fit(X_train, y_train)

"""### Prediction for Naive Bayes"""

y_predNB = modelNB.predict(X_test)

"""### Evaluation from Naive Bayes"""

accuracy = accuracy_score(y_test, y_predNB)
conf_matrix = confusion_matrix(y_test, y_predNB)
class_report = classification_report(y_test, y_predNB)

print(f'Accuracy: {accuracy*100:.2f}')
print('\nConfusion Matrix:\n', conf_matrix)
print('\nClassification Report:\n', class_report)

"""### Comparative Model Performance"""

accuracies = {
    'Logistic Regression': accuracy_score(y_test, y_predLR),
    'KNN': accuracy_score(y_test, y_predKNN),
    'Random Forest': accuracy_score(y_test, y_predRF),
    'SVM': accuracy_score(y_test, y_predSVM),
    'Naive Bayes': accuracy_score(y_test, y_predNB)
}

accuracy_df = pd.DataFrame.from_dict(accuracies, orient='index', columns=['Accuracy'])

accuracy_df['Accuracy'] = (accuracy_df['Accuracy'] * 100).map('{:.2f}%'.format)
display(accuracy_df)

"""### Count Plot"""

plt.figure(figsize=(15, 10))
for i, column in enumerate(df.columns[:-1], 1):
    plt.subplot(4, 5, i)
    sns.countplot(x=column, hue='COVID-19', data=df, palette='Set2')
    plt.title(f'Distribution of {column}')
    plt.xlabel(column)
    plt.ylabel('Count')
    plt.legend(title='COVID-19', loc='upper right')

plt.tight_layout()
plt.show()

"""### Confusion Matrix Heatmap"""

conf_matrix = confusion_matrix(y_test, y_predLR)
plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['No', 'Yes'], yticklabels=['No', 'Yes'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Logistic Regression')
plt.show()

conf_matrix = confusion_matrix(y_test, y_predKNN)
plt.figure(figsize=(6, 4))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues', xticklabels=['No', 'Yes'], yticklabels=['No', 'Yes'])
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix KNN')
plt.show()

"""### Feature Importance"""

X = df.drop('COVID-19', axis=1)
y = df['COVID-19']

model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

importances = model.feature_importances_
feature_importance_df['Importance'] = (feature_importance_df['Importance'] / feature_importance_df['Importance'].sum()) * 100

feature_importance_df = feature_importance_df.sort_values(by='Importance', ascending=False)

print(feature_importance_df)

plt.figure(figsize=(10, 6))
sns.barplot(x='Importance', y='Feature', data=feature_importance_df)
plt.title('Random Forest Feature Importance')
plt.xlabel('Importance')
plt.ylabel('Feature')
plt.show()

"""### ROC Curve & AUC Score"""

y_prob = modelLR.predict_proba(X_test)[:, 1]
fpr, tpr, _ = roc_curve(y_test, y_prob)
roc_auc = auc(fpr, tpr)
plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', label=f'ROC Curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], linestyle='--', color='gray')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve")
plt.legend()
plt.show()